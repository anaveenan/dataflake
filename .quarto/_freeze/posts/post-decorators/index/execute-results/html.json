{
  "hash": "96291a6877dfb98faa6cbd1d61985040",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Decorators\"\nauthor: \"Naveenan Arjunan\"\ndate: \"2024-03-02\"\ncategories: [python,advanced-python]\n\n---\n\n## Decorator \n\n### What are decorator ? \n\nA decorator is a special kind of callable that wraps another function or class to modify or enhance its behavior. They are used to apply repetitive operations or modifications across multiple functions or classes. You can introduce new behavior to functions or classes in several moments:\n\n1. At the time of their definition.   \n2. Just before they are called.    \n3. Right after they are called. \n\nTo illustrate how decorators works, consider the following example: we've have created a decorator named `dec`, a type of function that takes another function - let's say `hello` - as it parameter and that prints the name of the function. When you prepend `hello` with `@dec`, it effectively performs the operation `dec(hello)` behind the scenes.\n\n\n① - Prints the function name when the function is defined. Note the function is not called yet. \n\n::: {#b51447b7 .cell class-output='highlight' execution_count=1}\n``` {.python .cell-code}\ndef dec(func): \n    print(f\"Function: {func.__name__} is defined\") #① \n\n@dec\ndef hello():\n    print(\"hello\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFunction: hello is defined\n```\n:::\n:::\n\n\n### Basic decorator \nLet's extent the decorator from previous section to add the following additional behavior when the function is called.\n\n① - Print start prior to calling the function   \n② - Call the actual function   \n③ - Print end after calling the function   \n\n::: {#01c43bf8 .cell execution_count=2}\n``` {.python .cell-code}\ndef dec(func): \n    print(f\"Function: {func.__name__} is defined\")\n    def wrapper():\n        print(\"start\") #①\n        func() #② \n        print(\"end\")#③\n    return wrapper\n\n@dec\ndef hello():\n    print(\"hello\")\nprint('-' * 40)\n\nhello()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFunction: hello is defined\n----------------------------------------\nstart\nhello\nend\n```\n:::\n:::\n\n\n### Handling arguments in a decorator \n\n① - Pass arguments in the function  \n② - Add args and kwargs in the wrapper function arguments  \n③ - Call the function with the args and kwargs passed    \n\n::: {#ccc620fc .cell execution_count=3}\n``` {.python .cell-code}\ndef dec(func): \n    print(f\"Function: {func.__name__} is defined\")\n    def wrapper(*args,**kwargs): #②\n        print(\"start\") \n        func(*args,**kwargs) #③ \n        print(\"end\")\n    return wrapper\n\n@dec\ndef hello(x:str)->None:#①\n    \"\"\"concat hello with passed in string and print\"\"\"\n    print(f\"hello {x}\")\n\nhello('world')\n\nprint('-' * 40)\n\n#④\nprint(f\"Func. Name: {hello.__name__}\",sep='\\n')\nprint(f\"Docstring: {hello.__doc__}\",sep='\\n')\nprint(f\"Annotations: {hello.__annotations__}\",sep='\\n')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFunction: hello is defined\nstart\nhello world\nend\n----------------------------------------\nFunc. Name: wrapper\nDocstring: None\nAnnotations: {}\n```\n:::\n:::\n\n\n### Preserve decorator metadata\n\nWhen we use a decorator, the function `dec` is replaced by the `wrapper` function. This means we loose most of the properties like name, docstring, annotations, etc. We can use `functools.wraps`, which takes a function used in a decorator and add the functionality of copying over the function names, docstrings, annotation, etc. \n\n::: {#6eb9de7d .cell execution_count=4}\n``` {.python .cell-code}\nprint(f\"Func. Name: {hello.__name__}\",sep='\\n')\nprint(f\"Docstring: {hello.__doc__}\",sep='\\n')\nprint(f\"Annotations: {hello.__annotations__}\",sep='\\n')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFunc. Name: wrapper\nDocstring: None\nAnnotations: {}\n```\n:::\n:::\n\n\n::: {#9f2a10f2 .cell execution_count=5}\n``` {.python .cell-code}\nfrom functools import wraps \n\ndef dec(func): \n    print(f\"Function: {func.__name__} is defined\")\n    @wraps(func)\n    def wrapper(*args,**kwargs): #②\n        print(\"start\") \n        func(*args,**kwargs) #③ \n        print(\"end\")\n    return wrapper\n\n@dec\ndef hello(x:str)->None: #①\n    \"\"\"concat hello with passed in string and print\"\"\"\n    print(f\"hello {x}\")\n\nhello('world')\n\n#④\nprint(f\"Func. Name: {hello.__name__}\",sep='\\n')\nprint(f\"Docstring: {hello.__doc__}\",sep='\\n')\nprint(f\"Annotations: {hello.__annotations__}\",sep='\\n')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFunction: hello is defined\nstart\nhello world\nend\nFunc. Name: hello\nDocstring: concat hello with passed in string and print\nAnnotations: {'x': <class 'str'>, 'return': None}\n```\n:::\n:::\n\n\nReturning value from a decorated function\n\n::: {#75ad695a .cell execution_count=6}\n``` {.python .cell-code}\nfrom functools import wraps \n\ndef dec(func): \n    print(f\"Function: {func.__name__} is defined\")\n    @wraps(func)\n    def wrapper(*args,**kwargs): #②\n        print(\"start\") \n        result=func(*args,**kwargs) #①\n        print(\"end\")\n        return result #②\n    return wrapper\n\n@dec\ndef hello(x:str)->None: \n    \"\"\"concat hello with passed in string and print\"\"\"\n    print(f\"hello {x}\")\n    return 'hello'\n\nhello('world')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFunction: hello is defined\nstart\nhello world\nend\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n'hello'\n```\n:::\n:::\n\n\nPassing  value to a decorator function \n\n::: {#0e7187a9 .cell execution_count=7}\n``` {.python .cell-code}\nfrom functools import wraps \n\ndef dec(a,b): \n    def dec_decorator(func):\n        print(f\"Function: {func.__name__} is defined\")\n        @wraps(func)\n        def wrapper(*args,**kwargs): #②\n            print(f\"start:{a}\") \n            result=func(*args,**kwargs) #①\n            print(f\"end:{b}\")\n            return result #②\n        return wrapper\n    return dec_decorator\n\n@dec('a','b')\ndef hello(x:str)->None: \n    \"\"\"concat hello with passed in string and print\"\"\"\n    print(f\"hello {x}\")\n    return 'hello'\n\nhello('world')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFunction: hello is defined\nstart:a\nhello world\nend:b\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n'hello'\n```\n:::\n:::\n\n\nExample of a decorator \n\n::: {#737f25ac .cell execution_count=8}\n``` {.python .cell-code}\nfrom functools import wraps\nfrom time import perf_counter\ndef timer(func):\n    @wraps(func)\n    def wrapper(*args,**kwargs):\n        start_time=perf_counter()\n        func(*args,**kwargs)\n        end_time=perf_counter()\n        print(f\"\\N{Greek Capital Letter Delta} {end_time-start_time:.4f} sec\")\n    return wrapper\n\n@timer\ndef process_list(n=10000):\n    return sum(range(n))\n\nprocess_list()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nΔ 0.0002 sec\n```\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}